library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity fsm is 
	port (  RESET : in std_logic; 
    		CLK : in std_logic; 
            BUTLCHE: in std_logic; 
            BUTCRTO: in std_logic;
            BUTLRGO: in std_logic;
            BUTSOLO: in std_logic;
            BUTCONF: in std_logic;
            STR_OUT: out string (4 downto 1);
           	CATHODES : out std_logic_vector (28 downto 1);
            LIGHT : out std_logic_vector(0 TO 3));         
end fsm; 


architecture behavioral of fsm is 
	type STATES is (S0, S1); 
    signal current_state: STATES := S0; 
    signal next_state: STATES; 
    signal STR_IN : string (4 downto 1);
    signal tipo : string (4 downto 1);
    signal en	: std_logic := '0';
    signal TIMEOUT: std_logic :='0';
    signal val : unsigned (255 downto 0);
    signal ready : std_logic :='0';
    signal ResetTimer : std_logic :='1';
    signal ResetPulse : std_logic := '0';
    component STR27SEG is
		port(
			STR_IN	: in string(4 downto 1);
    		CATHODES: out std_logic_vector(28 downto 1)
		);
	end component;
    
    component temporizador is
          port(
              clk		: in std_logic;
              reset	: in std_logic;
              en		: in std_logic;
              val		: in unsigned(255 downto 0);
              fin		: out std_logic;
          );
	end component;
    
    
    
	begin state_register:
    
    	STR27SEG port map(
        	STR_IN => STR_IN,
            CATHODES => CATHODES
        );
        
        temp: temporizador port map(
        	clk=>CLK,
            reset=>ResetPulse,
            en=>en,
            val=>val,
            fin=>TIMEOUT
        );
    	process (RESET, CLK) 
        begin 
            if reset='1' then 
            	current_state <= S0;
            elsif CLK'event and CLK='1' then
            	current_state <= next_state;
            end if;
        end process;
        nextstate_decod: process(BUTCONF,current_state, ready,STR_IN)
        begin 
        next_state <= current_state; 
        case current_state is 
            when S0 => if BUTCONF = '1' then next_state <= S1; 
                tipo <= STR_IN;
                end if;
            when S1 => if ready = '1' then next_state <= S0; 				end if; 
            when others => next_state <= S0; 
        end case; 
    end process;
    output_decod: process (current_state, tipo, STR_IN,CLK) 
    variable flag_pulso_pendiente : std_logic;
    begin 
        case current_state is 
            when S0 => LIGHT <= (OTHERS => '0');
            ResetTimer <= '1';
            	if CLK'event and CLK='1' and BUTLCHE = '1' then
                	STR_IN <= "LCHE";
                    STR_OUT <= STR_IN;
                elsif CLK'event and CLK='1' and BUTCRTO = '1' then
                	STR_IN <= "CRTO";
                elsif CLK'event and CLK='1' and BUTLRGO = '1' then
                	STR_IN <= "LRGO";
                elsif CLK'event and CLK='1' and BUTSOLO = '1' then
                	STR_IN <= "SOLO";
                end if;
            when S1 => 
            	
            	if CLK'event and CLK='1' and tipo = "LCHE" then					
					if ResetTimer = '1' then
        				flag_pulso_pendiente := '1';
                    end if;
     				if rising_edge(clk) then
                    	ResetPulse <= '0';
                    	LIGHT(2) <= '1';
                		val <= to_unsigned(15, val'length);
                    	en <= '1';
        				if flag_pulso_pendiente = '1' then
                        	ResetPulse <= '1';
                            ResetTimer<= '0';
          					flag_pulso_pendiente := '0';
        				end if;
    				end if; 
                    ready <= TIMEOUT;
                 elsif CLK'event and CLK='1' and tipo = "SOLO" then
                 	LIGHT(3) <= '1';
                 	val <= to_unsigned(15, val'length);
                    en <= '1';
                    ready <= TIMEOUT;
                 elsif CLK'event and CLK='1' and tipo = "LRGO" then
             		LIGHT(3) <= '1'; 
                 	val <= to_unsigned(10, val'length);
                    en <= '1';
                    if CLK'event and CLK='1' and TIMEOUT = '1' then
                    	ResetTimer <= '1';
                    	LIGHT(2) <= '1'; 
                    	val <= to_unsigned(5, val'length);
                    	en <= '1';
                        ready <= TIMEOUT;
                     end if;
                 elsif CLK'event and CLK='1' and tipo = "CRTO" then
                 	LIGHT(3) <= '1'; 
                 	val <= to_unsigned(5, val'length);
                    en <= '1';
					if CLK'event and CLK='1' and TIMEOUT = '1' then
                    	TIMEOUT <= '0';
                    	ResetTimer <= '1';
                    	val <= to_unsigned(10, val'length);
                    	en <= '1';
                        ready <= TIMEOUT;
                     end if;
                 end if;
            when others => LIGHT <= (OTHERS => '0');
        end case; 
    end process; 
end behavioral;
--
--
--
--
--STR27SEG CODE
--
--
--
--
library IEEE;
use IEEE.std_logic_1164.all;

entity STR27SEG is
port(
	STR_IN	: in string(4 downto 1);
    CATHODES: out std_logic_vector(28 downto 1)
	);
end STR27SEG;

architecture MODULAR of STR27SEG is
  component CHAR27SEG
  	port(
        CHAR_IN		: in character;
        CATHODES	: out std_logic_vector(7 downto 1)
     );
  end component;

begin
CHAR_DECODER_1: CHAR27SEG port map( CHAR_IN => STR_IN(1),
									CATHODES => CATHODES(7 downto 1)
						 		  );
CHAR_DECODER_2: CHAR27SEG port map( CHAR_IN => STR_IN(2),
									CATHODES => CATHODES(14 downto 8)
						 		  );
CHAR_DECODER_3: CHAR27SEG port map( CHAR_IN => STR_IN(3),
									CATHODES => CATHODES(21 downto 15)
						 		  );
CHAR_DECODER_4: CHAR27SEG port map( CHAR_IN => STR_IN(4),
									CATHODES => CATHODES(28 downto 22)
						 		  );
end MODULAR;                                  

library IEEE;
use IEEE.std_logic_1164.all;

entity CHAR27SEG is
	port(
		CHAR_IN		: in character;
    	CATHODES	: out std_logic_vector(7 downto 1)
    );
end CHAR27SEG;

architecture DATAFLOW of CHAR27SEG is
begin
	with CHAR_IN select
    	CATHODES <=	
        	"0000001" when '0', -- Catodo comun, 0 => segmento encendido
            "1001111" when '1',
            "0010010" when '2',
            "0000110" when '3',
            "1001100" when '4',
            "0100100" when '5',
            "0100000" when '6',
            "0001111" when '7',
            "0000000" when '8',
            "0000100" when '9',
            "0001000" when 'A',
            "0110001" when 'C',
            "0000001" when 'O',
            "1111010" when 'R',
            "1110001" when 'L',
            "1110000" when 'T',
            "0110000" when 'E',
            "1001000" when 'H',
            "1000001" when 'U',
            "0100001" when 'G',
            "0100100" when 'S',
            "1111001" when 'I',
            "1101010" when 'N',
            "0010010" when 'Z',
            "1111111" when ' ',
            "1111110" when '-',
            "1111110" when others;
end DATAFLOW;
--
--
--
--
--TEMPORIZADOR CODE
--
--
--
--
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity temporizador is
port(
	clk		: in std_logic;
    reset	: in std_logic;
    en		: in std_logic;
    val		: in unsigned(255 downto 0);
    fin		: out std_logic;
);
end temporizador;

architecture modular of temporizador is
	signal clk_i		: std_logic;
    signal cnt_out_i	: unsigned(val'range);

	component comparador is
	port(
		in_1	: IN unsigned(255 downto 0);
        igual: OUT STD_LOGIC;
		mayor: OUT STD_LOGIC;
		menor: OUT STD_LOGIC
    );
    end component;
    
    component freq_div is
	generic(modulo:positive:=2);
	port(
        clk_in	: in std_logic;
        reset	: in std_logic;
        EN		: in std_logic;
	 	clk_out : out std_logic
	);  
    end component;
    
    component contador is
 	port (
 		reset	: in std_logic;
        clk 	: in std_logic;
        en		: in std_logic;
        val		: in unsigned(255 downto 0);
 		cnt 	: out unsigned(255 downto 0);
 	);
    end component;
  
begin 

	fdiv: freq_div 
    generic map(modulo => 5)
    port map(
        clk_in => clk,
        reset => reset,
        EN => en,
        clk_out => clk_i
    ); 
    
    cmp: comparador port map(
    	in_1 => cnt_out_i,
        igual => fin
    );
    
    cnt: contador port map(
 		reset => reset,
        clk => clk_i,
        en	=> en,
        val	=> val,
 		cnt => cnt_out_i
 	);
end modular;

--Contador 
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity contador is
 	port (
 		reset	: in std_logic;
        clk 	: in std_logic;
        en		: in std_logic;
        val		: in unsigned(255 downto 0);
 		cnt 	: out unsigned(255 downto 0);
 );
end contador;

architecture behavioural of contador is
	signal cnt_i : unsigned(cnt'range);
begin
 	counter: process (reset, clk)
 		begin
 			if reset = '1' then
            	cnt_i <= val;
            elsif rising_edge(clk) then
            	if en = '1' then
                	if cnt_i>0 then 
 						cnt_i <= cnt_i - 1;
                    end if;
                end if;
 			end if;
 	end process;
    cnt <= cnt_i;
end behavioural;

--Divisor de frecuencias
library IEEE;
use IEEE.std_logic_1164.all;

entity freq_div is
	generic(modulo:positive:=2);
	port(clk_in, reset, EN: in std_logic;
	 clk_out : out std_logic
	);
end freq_div;

architecture Behavioral of freq_div is
signal clk_out_signal:std_logic;

begin --arch
	process(clk_in, reset, EN) 
    variable contador: positive := modulo+1; --positive va de 1 a nosecuantos
    begin -- process
    	if reset='1' then -- if reset
            clk_out_signal <= '0';
            clk_out<=clk_out_signal;
            contador := modulo;-- si hago un subtipo podría hacer subtipo'high
         elsif clk_in'event and clk_in='1' then --flanco de subida, tb risign_edg(clk_in)
         	if EN='1' then --if enable 
            	if contador /= 1 then--if contador --0 si integer, '0' si booleano, "0" si vector
                  contador:= contador-1;
            	else
                  clk_out_signal <= not clk_out_signal; --Toggle
                  contador:= modulo;
               	end if; --if contador
             end if; --if enable
         end if; -- if reset
         clk_out <= clk_out_signal;
    end process; -- process
end behavioral; --arch

--Comparador a cero
library IEEE;
use ieee.std_logic_1164.all;
use IEEE.numeric_std.all;

ENTITY comparador IS
	PORT(
		in_1: IN unsigned(255 downto 0);
        igual: OUT STD_LOGIC;
		mayor: OUT STD_LOGIC;
		menor: OUT STD_LOGIC
    );

END comparador;

ARCHITECTURE arch1 OF comparador IS
BEGIN
	igual <= '1' WHEN in_1 = to_unsigned(0, in_1'length) ELSE '0';
	mayor <= '1' WHEN in_1 > to_unsigned(0, in_1'length) ELSE '0'; 
	menor <= '1' WHEN in_1 < to_unsigned(0, in_1'length) ELSE '0'; 
END arch1;
